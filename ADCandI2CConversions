#include <msp430.h>

unsigned int ADC_Result[4];                                    // 12-bit ADC conversion result array
unsigned char i;

int main(void)
{
    WDTCTL = WDTPW | WDTHOLD;                                   // Stop WDT

    // Configure ADC A0~2 pins
    P1SEL0 |=  BIT1 + BIT2 + BIT3;
    P1SEL1 |=  BIT1 + BIT2 + BIT3;

    // Disable the GPIO power-on default high-impedance mode to activate
    // previously configured port settings
    PM5CTL0 &= ~LOCKLPM5;

    // Configure ADC
    ADCCTL0 |= ADCSHT_2 | ADCON;                                // 16ADCclks, ADC ON
    ADCCTL1 |= ADCSHP | ADCSHS_2 | ADCCONSEQ_3;                 // ADC clock MODCLK, sampling timer, TB1.1B trig.,repeat sequence
    ADCCTL2 &= ~ADCRES_2;                                         // 8-bit conversion results
    ADCMCTL0 |= ADCINCH_2 | ADCSREF_1;                          // A0~2(EoS); Vref=1.5V
    ADCIE |= ADCIE0;                                            // Enable ADC conv complete interrupt

    // Configure reference
    PMMCTL0_H = PMMPW_H;                                        // Unlock the PMM registers
    PMMCTL2 |= INTREFEN | TSENSOREN | REFVSEL_0;                                        // Enable internal reference
    __delay_cycles(400);                                        // Delay for reference settling

    // Configure TB1.1B as ADC trigger signal
    // Note: The TB1.1B is configured for 200us 50% PWM, which will trigger ADC
    // sample-and-conversion every 200us. The period of TB1.1B trigger event
    // should be more than the time period taken for ADC sample-and-conversion
    // and ADC interrupt service routine of each channel, which is about 57us in this code
    TB1CCR0 = 200-1;                                            // PWM Period, 200us
    TB1CCTL1 = OUTMOD_7;                                        // CCR1 reset/set
    TB1CCR1 = 100;                                              // CCR1 PWM duty cycle, 50%
    TB1CTL = TBSSEL__SMCLK | MC__UP | TBCLR;                    // SMCLK, up mode, clear TAR

    i = 3;

    while(1)
    {
        ADCCTL0 |= ADCENC;                                       // Enable ADC
        TB1CTL |= TBCLR;                                         // Clear TAR to start the ADC sample
        __bis_SR_register(LPM0_bits |GIE);                      // Enter LPM0 w/ interrupts
        __no_operation();                                        // Only for debug
    }
}

// ADC interrupt service routine
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector=ADC_VECTOR
__interrupt void ADC_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(ADC_VECTOR))) ADC_ISR (void)
#else
#error Compiler not supported!
#endif
{
    switch(__even_in_range(ADCIV,ADCIV_ADCIFG))
    {
        case ADCIV_NONE:
            break;
        case ADCIV_ADCOVIFG:
            break;
        case ADCIV_ADCTOVIFG:
            break;
        case ADCIV_ADCHIIFG:
            break;
        case ADCIV_ADCLOIFG:
            break;
        case ADCIV_ADCINIFG:
            break;
        case ADCIV_ADCIFG:
            ADC_Result[i] = ADCMEM0;
            if(i == 0)
            {
                __no_operation();   // Only for debug
                i = 3;
            }
            else
            {
                i--;
            }
            break;
        default:
            break;
    }
}
